package proofutil;

import de.uka.ilkd.key.java.Services;
import de.uka.ilkd.key.pp.LogicPrinter;
import de.uka.ilkd.key.proof.Goal;
import de.uka.ilkd.key.proof.Node;
import de.uka.ilkd.key.proof.Proof;
import de.uka.ilkd.key.rule.OneStepSimplifier.Protocol;
import de.uka.ilkd.key.rule.OneStepSimplifierRuleApp;
import de.uka.ilkd.key.rule.RuleApp;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/**
 * This class allows to transforma a proof tree generated by KeY (see {@link
 * de.uka.ilkd.key.proof.Proof}) into a more lightweight tree structure, which just contains the
 * data, the KollaborierbaR client needs for its features. Therefore, there is no need to replicate
 * the complex data structures of KeY at the client side.
 *
 * <p>The generated tree consists of {@link proofutil.ProofNode} instances.
 *
 * <p>This code is in part based on code of the classes of the package {@link
 * de.uka.ilkd.key.gui.prooftree} of the KeY UI, since it too needs to transform the KeY proof tree
 * into a format, useful for UI (tree) views. Therefore the copyright of KeY project contributors
 * applies:
 *
 * <p>Copyright (C) 2001-2011 Universitaet Karlsruhe (TH), Germany Universitaet Koblenz-Landau,
 * Germany Chalmers University of Technology, Sweden Copyright (C) 2011-2014 Karlsruhe Institute of
 * Technology, Germany Technical University Darmstadt, Germany Chalmers University of Technology,
 * Sweden
 *
 * <p>And the various authors of said package.
 */
class ProofTreeBuilder {
  public ProofTreeBuilder() {}

  /**
   * Transforms a KeY proof into a {@link proofutils.ProofNode} based representation, as explained
   * in the description of this class.
   */
  public ProofNode generateProofTree(final Proof proof) {
    final ProofNode.Kind kind;

    if (proof.closed()) {
      kind = ProofNode.Kind.ClosedProofTree;
    } else {
      kind = ProofNode.Kind.OpenProofTree;
    }

    return generateBranchNode(proof.root(), proof.name().toString(), kind);
  }

  /**
   * Helper method for {@link #generateBranchNode}. It finds the next child of a branch node, which
   * is not itself a branch node, based on the previous one.
   *
   * <p>If there is just a single in the given node, it will be returned. Otherwise, it will return
   * its first unclosed child, if it is the only unclosed child.
   *
   * @return a child of a parent branch node or {@code null}, if there remain none, which are not
   *     branch nodes.
   */
  private Node findChild(Node n) {
    if (n.childrenCount() == 1) {
      return n.child(0);
    }

    // search for the first unclosed child
    Node nextN = null;
    for (int i = 0; i != n.childrenCount(); ++i) {
      if (!n.child(i).isClosed()) {
        // if there has been another unclosed child, abort.
        if (nextN != null) {
          return null;
        }
        nextN = n.child(i);
      }
    }

    return nextN;
  }

  /**
   * Generates a node of the BranchNode type from the given KeY proof node. Usually the parameters
   * {@code forcedLabel} and {@code forcedKind} are only used when generating the root of a tree.
   * (see {@link #generateProofTree})
   *
   * @param node KeY node that is to be transformed into a {@link ProofNode}
   * @param forcedLabel The caller can force the use of this string as the display text (see {@link
   *     proofutils.ProofNode#getText}). If this parameter is not {@code null}, it will be used
   *     instead of a automatically generated value.
   * @param forcedKind The caller can force the use of this parameter as the node kind (see {@link
   *     proofutils.ProofNode#getKind}). If this parameter is not {@code null}, it will be used
   *     instead of a automatically generated value.
   * @return a node of kind "BranchNode", or of {@code forcedKind}, if present.
   */
  private ProofNode generateBranchNode(
      final Node node, final String forcedLabel, final ProofNode.Kind forcedKind) {
    // determine the display text of the node, use the forced one, if present.
    final String label;
    {
      if (forcedLabel != null) {
        label = forcedLabel;
      } else if (node.getNodeInfo().getBranchLabel() != null) {
        // if there has no label been forced, use the one provided by KeY,
        // if present.
        label = node.getNodeInfo().getBranchLabel();
      } else {
        // if all other methods fail, use this default value
        label = "(Unlabelled node)";
      }
    }

    // analogous to determining the display text.
    final ProofNode.Kind kind;
    if (forcedKind == null) {
      kind = ProofNode.Kind.BranchNode;
    } else {
      kind = forcedKind;
    }

    // populate the branch node's list of children
    final List<ProofNode> children = new LinkedList<>();
    {
      Node currentNode = node;

      while (true) {
        children.add(generateDefaultNode(currentNode));

        final Node nextN = findChild(currentNode);
        // add children, until there remain none to be added
        if (nextN == null) {
          break;
        }

        currentNode = nextN;
      }

      // if there are unclosed children in the last node added, those are always
      // branch nodes and need to be added as children, too.
      for (int i = 0; i != currentNode.childrenCount(); ++i) {
        if (!currentNode.child(i).isClosed()) {
          children.add(generateBranchNode(currentNode.child(i), null, null));
        }
      }
    }

    final String sequent =
        LogicPrinter.quickPrintSequent(node.sequent(), node.proof().getServices());

    return new ProofNode(label, children, kind, sequent, node.serialNr(), 0);
  }

  /**
   * Generate a node representing a step during a One Step Simplification in the KeY proof.
   *
   * @param Services collection of services used by the KeY prover. Used here for rendering terms.
   *     Can be retrieved from {@link de.uka.ilkd.key.proof.Proof}.
   * @param ruleApp application of the rule represented by this step of the simplification. Used to
   *     generate a human readable display text for the node.
   * @param parentSerialNr unique serial number of the parent node, together with {@code oneStepId}
   *     this forms a unique key for identifying this node within the whole tree. The resulting node
   *     will replicate the parents serial number with {@link proofutils.ProofNode#getSerialNr}.
   * @param oneStepId unique identifier of the node among its siblings.
   * @return a node of kind "OneStepSimplification"
   */
  private ProofNode generateOneStepNode(
      final Services services, final RuleApp app, final int parentSerialNr, final int oneStepId) {
    final String prettySubTerm =
        LogicPrinter.quickPrintTerm(app.posInOccurrence().subTerm(), services);

    return new ProofNode(
        app.rule().name() + " ON " + prettySubTerm,
        new ArrayList<ProofNode>(0),
        ProofNode.Kind.OneStepSimplification,
        "",
        parentSerialNr,
        oneStepId);
  }

  /**
   * Generates a regular node from the given KeY proof node. Depending on whether it is a leaf and
   * whether its closed it will assume one of the following kinds:
   *
   * <p>- DefaultNode (no leaf) - OpenGoal - ClosedGoal - LinkedGoal - InteractiveGoal
   *
   * @param node KeY node that is to be transformed into a {@link ProofNode}
   */
  private ProofNode generateDefaultNode(final Node node) {
    final List<ProofNode> children;

    // Does the node represent a one step simplification?
    if (node == null || !(node.getAppliedRuleApp() instanceof OneStepSimplifierRuleApp)) {
      // if not, register no children
      children = new ArrayList<>(0);
    } else {
      // otherwise generate children for the applied rules
      final Protocol protocol = ((OneStepSimplifierRuleApp) node.getAppliedRuleApp()).getProtocol();

      if (protocol != null) {
        final int numChildren = protocol.size();
        children = new ArrayList<>(numChildren);

        for (int i = 0; i < numChildren; ++i) {
          children.add(
              generateOneStepNode(node.proof().getServices(), protocol.get(i), node.serialNr(), i));
        }
      } else {
        children = new ArrayList<>(0);
      }
    }

    // determine the nodes kind, based on whether it is a leaf and closed or not etc.
    final ProofNode.Kind kind;
    if (node.leaf()) {
      final Goal goal = node.proof().getGoal(node);

      if (goal == null || node.isClosed()) {
        kind = ProofNode.Kind.ClosedGoal;
      } else {
        if (goal.isLinked()) {
          kind = ProofNode.Kind.LinkedGoal;
        } else if (!goal.isAutomatic()) {
          kind = ProofNode.Kind.InteractiveGoal;
        } else {
          kind = ProofNode.Kind.OpenGoal;
        }
      }
    } else {
      kind = ProofNode.Kind.DefaultNode;
    }

    final String sequent =
        LogicPrinter.quickPrintSequent(node.sequent(), node.proof().getServices());

    return new ProofNode(
        node.serialNr() + ":" + node.name(), children, kind, sequent, node.serialNr(), 0);
  }
}
